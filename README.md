# ![Go](https://img.shields.io/badge/go-%2300ADD8.svg?style=for-the-badge&logo=go&logoColor=white) Candy Cache :candy:

**CandyCache** — это простой и эффективный кэш на языке Go, который позволяет хранить данные с ограниченным временем жизни (TTL). 

# Установка

Для использования CandyCache в вашем проекте, установите его, используя **go get git.hikan.ru/serr/candycache**, далее просто добавьте в блок импорта.

# Основные возможности

- **Автоматика**: автоматическая очистка устаревших элементов и возможность ее отключения
- **Возможность ручного управления**
- **Безопасность**: конкурентный доступ к данным возможен благодаря мьютексам
- **Гибкость**: кэш может хранить любые типы данных

# Использование

## Создание кэша

Для создания нового экземпляра кэша используйте функцию **Cacher**, передавая интервал очистки в наносекундах.

Если требуется указать интервал в секундах/минутах/часах и т.д. - используйте множители из пакета **time**:
```go
cache := candycache.Cacher(10 * time.Minute) // Очистка каждые 10 минут
```

Если автоматичская очистка не нужна - просто передайте параметром любое отрицательное число:

```go
cache := candycache.Cacher(-1) // Кэш не будет очищаться автоматически
```

## Добавление элемента

Для добавления элемента в кэш используйте метод **Add**:
```go
cache.Add("key", "value", 5 * time.Minute) // Элемент будет считаться устаревшим через 5 минут
```
В случае, если по указанном ключу уже что-то хранится, оно будет заменено на новый элемент.

## Получение элемента

Для получения элемента из кэша используйте метод **Get**:

```go
value, found := cache.Get("key") // Получение значения по ключу "key"
```
Если элемент найден, то в переменную **value** будет записано значение, а в **found** — **true**. Если элемент не найден, то в **found** будет записано **false**, а значением вернется **nil**